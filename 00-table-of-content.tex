%!TEX root = main.tex
%\chapter{Abstract}
% \chapter{Table of Content}

% List papers and chapter to review. Overall idea of how to organize the report is been written here and I will continue the report as I go forward.


% \begin{itemize}
% \item Introduction
%     \begin{itemize}
%         \item What was the problem?
%         \item More's Law and end of Dennard scaling  and Power wall-> 2000
%         \item More's Law for multicores and Dark silicon -> 2005 
%         \item Accelerator wall -> 2019
%     \end{itemize}
% \end{itemize}
        
% On one hand, this shift in structure has made computation more energy efficient; on the
% other, it has made programming the resulting systems much more complex. The vast majority of algorithms and programming languages were created for an abstract computing machine running a single thread of control, with access to the entire memory of the machine. Changing these algorithms and languages to leverage multiple threads is difficult, and mapping them to use the specialized processors is near impossible. As a result, accelerators only get used when
% performance is essential to the application; otherwise, the code is written for CPU and declared “good enough.” Unless \textit{we develop new languages and tools that dramatically simplify the task of mapping algorithms onto these modern heterogeneous machines, computing performance will stagnate.}

% This report, describes different approaches that been used to address this issue.

% But first I explain:
% 1. Dennard and how performance scales with technology
% 2. Levels of abstraction Y-chart
% 3. Hardware accelerators, metrics to measure a good hardware accelerator: Performance, power, area and flexibility
% 3. Cost of hardware acceleration: 
%     1)Introducing new instructions (SSE, AVX)? 
%     2)Heterogeneous ISA (GPUs)? 
%     3)Configurable accelerator (CGRAs)?
%     4)Application specific accelerator (HLS)
    
% 4. Good applications for acceleration? Are all the applications can benefit from hardware acceleration?


% \begin{itemize}
%     \item Processor and instruction set (ISA)
%     \item Data parallelism and SIMD instructions
%     \item More complex instructions set like TRIPS and CCA
% \end{itemize}

% Heterogenous ISAs like GPUs.
% GPU, OpenMP, CUDA and so on (I don't know which category they fall in right now)


% CGRA and DYSER
% mapping problem and compiler
% Instruction scheduling for CGRA


% Application specific accelerators:
% \begin{itemize}
%     \item Domain Specific compilers: Delite
%     \item Domain Specific languages: Spatial, Halide, Darkroom
%     \item FPGAs and how hard to program an FPGA -> HLS: Xlinx, Intel, Catapuls and Legup
% \end{itemize}





